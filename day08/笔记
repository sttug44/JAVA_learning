子类所覆写的方法不能比父类拥有更严格的访问控制权限

接口没有方法体，必须实现
implements

所有的子类转换为父类都可以
父类转子类强制转换
没有继承关系的两个类，互相转换，一定会失败
实现类转接口一定成功

instanceof Hero 判断一个引用所指向的对象，是否是Hero类型，或者Hero的子类

子类可以继承父类的对象方法
在继承后，重复提供该方法，就叫做方法的重写
又叫覆盖 override

操作符的多态
+ 可以作为算数运算，也可以作为字符串连接
如果+号两侧，任意一个是字符串，那么+代表字符串连接

要实现类的多态，需要如下条件
1. 父类（接口）引用指向子类对象
2. 调用的方法有重写

隐藏，就是子类覆盖父类的类方法

类的方法无论怎样使用都是它该类的方法，不可能是对象所在类的方法

实例化一个ADHero(), 其构造方法会被调用
其父类的构造方法也会被调用
并且是父类构造方法先调用
子类构造方法会默认调用父类的 无参的构造方法

使用关键字super 显式调用父类带参的构造方法

Object类是所有类的父类

Object类提供一个toString方法，所以所有的类都有toString方法
toString()的意思是返回当前对象的字符串表达
通过 System.out.println 打印对象就是打印该对象的toString()返回值

equals() 用于判断两个对象的内容是否相同

== 用于判断两个引用，是否指向了同一个对象

hashCode方法返回一个对象的哈希值

当Hero被修饰成final的时候，表示Hero不能够被继承
Hero的useItem方法被修饰成final,那么该方法在ADHero中，不能够被重写
final修饰基本类型变量，表示该变量只有一次赋值机会
final修饰引用，表示该引用只有1次指向对象的机会

在类中声明一个方法，这个方法没有实现体，是一个“空”方法
这样的方法就叫抽象方法，使用修饰符“abstract"
当一个类有抽象方法的时候，该类必须被声明为抽象类，子类会被要求实现方法
一旦一个类被声明为抽象类，就不能够被直接实例化
抽象类可以没有抽象方法

抽象类和接口的区别
区别1：
子类只能继承一个抽象类，不能继承多个
子类可以实现多个接口
区别2：
抽象类可以定义
public,protected,package,private
静态和非静态属性
final和非final属性
但是接口中声明的属性，只能是
public
静态
final的
即便没有显式的声明
注: 抽象类和接口都可以有实体方法。 接口中的实体方法，叫做默认方法

内部类分为四种：
非静态内部类
静态内部类
匿名类
本地类

非静态内部类可以直接在一个类里面定义
语法: new 外部类().new 内部类()
非静态内部类，是可以直接访问外部类的private实例属性name
非静态内部类，只有一个外部类对象存在的时候，才有意义

静态内部类水晶类的实例化 不需要一个外部类的实例为基础，可以直接实例化
语法：new 外部类.静态内部类();
因为没有一个外部类的实例，所以在静态内部类里面不可以访问外部类的实例属性和方法
除了可以访问外部类的私有静态成员外，静态内部类和普通类没什么大的区别

匿名类指的是在声明一个类的同时实例化它

本地类可以理解为有名字的匿名类
内部类与匿名类不一样的是，内部类必须声明在成员的位置，即与属性和方法平等的位置。
本地类和匿名类一样，直接声明在代码块里面，可以是主方法，for循环里等等地方